-- This module constructs hash functions for flow keys using dynasm

module(..., package.seeall)

local bit  = require("bit")
local dasm = require("dasm")
local ffi  = require("ffi")

local debug = false

-- constants for 32-bit FNV hashing
-- see http://www.isthe.com/chongo/tech/comp/fnv/index.html
local basis = 216613626ULL
local FNVp  = 16777619ULL

|.arch x64
|.actionlist actions

-- the definitions here (anchor, assemble, gen) are borrowed from lwaftr
-- (see multi_copy.lua)
__anchor = {}

local function assemble (name, prototype, generator)
   local Dst = dasm.new(actions)
   generator(Dst)
   local mcode, size = Dst:build()
   table.insert(__anchor, mcode)
   if debug then
      print("mcode dump: "..name)
      dasm.dump(mcode, size)
   end
   return ffi.cast(prototype, mcode)
end

-- this is a straightforward transcription of the FNV algorithm into
-- assembly, see the Lua version below
local function gen_hash(size)
   local function gen(Dst)
      -- rdi stores the buffer address
      -- rax stores the hash
      -- rcx is the loop index
      | mov rcx, size
      | mov eax, basis
      | mov r8, FNVp

      -- main loop
      |1:
      | xor al, byte [rdi]
      | mul r8
      | inc rdi
      | dec rcx
      | jnz <1

      -- shift hash by one
      | shl eax, 1
      | ret
   end

   return gen
end

function make_fnv_hash(size)
   return assemble("make_fnv_hash",
                   ffi.typeof("uint32_t (*)(void*)"),
                   gen_hash(size))
end

-- lua version for corectness comparison
local uint32_cast = ffi.new('uint32_t[1]')
local bxor, lshift = bit.bxor, bit.lshift
local function make_lua_hash(size)
   return function(key)
      local octets = ffi.cast("uint8_t*", key)
      local hash = basis
      for i=0, size-1 do
         hash = bxor(hash, octets[i])
         hash = hash * FNVp
      end

      -- see ctable.lua for why we do this
      local i32 = lshift(hash, 1)
      uint32_cast[0] = i32
      return uint32_cast[0]
   end
end

function selftest()
   -- test that the lua and dasm versions produce the same output
   local function test(size)
      local dasm_hash = make_fnv_hash(size)
      local lua_hash = make_lua_hash(size)
      assert(size < 10)

      for i=0, 255 do
         -- note: the behavior can be wrong if we pass a short
         --       (e.g., len 1) array here probably due to calling
         --       convention so be careful
         local buf = ffi.new("uint8_t[10]")
         for j=0, size-1 do
            buf[j] = i
         end
         local h1 = dasm_hash(buf)
         local h2 = lua_hash(buf)
         assert(h1 == h2, string.format("%d: %d != %d", size, h1, h2))
      end
   end

   test(1)
   test(2)

   print("selftest ok")
end
