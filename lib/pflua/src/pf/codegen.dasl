module(..., package.seeall)

local ffi = require("ffi")
local bit = require("bit")
local C = ffi.C

local dasm = require("dasm")

local regalloc = require("pf.regalloc")

|.arch x64
|.actionlist actions

-- Table keeping machine code alive to the GC.
local anchor = {}

local debug = true

local blk_label    = 2
local blk_bindings = 3
local blk_control  = 4

-- Note that we always negate the condition because the ordering
-- of the SSA IR puts the true branch first
local jmp_types =
   { ["=="] = "je",
     [">="] = "jl",
     ["<="] = "jg",
     [">"]  = "jle",
     ["<"]  = "jge", }

-- translate a variable occurrence into the appropriate
-- register, perhaps consulting the register allocation
function translate_variable(var)
   if var == "P" then
      return "edi"
   elseif var == "len" then
      return "esi"
   end
end

-- extract a number from an SSA IR label
function label_num(label)
   return tonumber(string.match(label, "L(%d+)"))
end

-- compile an expression that appears in the argument position of a return
function compile_expr(Dst, expr)
   local op = expr[1]

   if op == "=" then
      local lhs = expr[2]
      local rhs = expr[3]

      -- TODO: is it actually the case that rhs is always an immediate?
      compile_expr(Dst, lhs)

      | cmp rax, rhs
      | je >1
      | jmp >2
   elseif op == "[]" then
      local offset = expr[2]
      local bytes  = expr[3]

      -- the "P" variable is in %edi since it's the first argument
      if bytes == 1 then
         | movzx eax, byte [edi + offset]
      elseif bytes == 2 then
         | movzx eax, word [edi + offset]
      else
         | mov eax, dword [edi + offset]
      end
   else
      error(string.format("NYI expr %s", op))
   end
end

local function compile_cmp(Dst, var, const, alloc)
   if var == "P" then
      | cmp edi, const
      return
   elseif var == "len" then
      | cmp esi, const
      return
   end

   local reg = alloc[var]

   if type(reg) == "table" then
     -- spill case
     local offset = (reg.spill - 1) * 32
     | cmp dword [rsp + offset], const
   else
     | cmp Rq(reg), const
   end
end

-- generate a move from rax to the appropriate register
local function compile_var_move(Dst, var, alloc)
   local reg = alloc[var]

   if type(reg) == "table" then
      -- spill case
      local offset = (reg.spill - 1) * 32
      | mov [rsp + offset], rax
   else
      | mov Rq(reg), rax
   end
end

local function compile(ssa, alloc, dump)
   local Dst = dasm.new(actions)

   -- number of =>(...) style labels, we need a maximum
   -- of one per SSA block label plus a few special ones
   local order = ssa.order
   local maxpc = #order
   local label_map = {}

   Dst:growpc(maxpc)

   -- map ir labels to pc labels
   -- pc labels start at 0, so decrement
   for idx, label in ipairs(order) do
      label_map[label] = idx - 1
   end

   -- allocate space for all spilled vars
   local spilled_space = alloc.num_spilled * 32
   if spilled_space > 0 then
      | sub rsp, spilled_space
   end

   local blocks = ssa.blocks
   for _, label in ipairs(order) do
      local block = blocks[label]

      cur_label = label_map[label]
      |=>(cur_label):

      local control = block.control
      local bindings = block.bindings
      local op = control[1]

      for _, binding in ipairs(bindings) do
         compile_expr(Dst, binding.value)
         compile_var_move(Dst, binding.name, alloc)
      end

      if op == "if" then
         local cmp_op = control[2][1]
         local jmp_instr = jmp_types[cmp_op]
         local const = control[2][3]

         -- TODO: abstract some of this label handling
         local next_label = label_map[control[4]]

         compile_cmp(Dst, control[2][2], const, alloc)

         -- TODO: this feels very hackish
         if cmp_op == "=" then
            | jne =>(next_label)
         elseif cmp_op == ">=" then
            | jl =>(next_label)
         elseif cmp_op == "<=" then
            | jg =>(next_label)
         elseif cmp_op == ">" then
            | jle =>(next_label)
         elseif cmp_op == "<" then
            | jge =>(next_label)
         end
      elseif op == "return" then
         local expr = control[2]

         if #expr == 1 and expr[1] == "true" then
            | jmp >1
         elseif #expr == 1 and expr[1] == "false" then
            | jmp >2
         else
            compile_expr(Dst, expr)
         end
      else
	 error(string.format("NYI op %s", op))
      end
   end

   -- return true, false
   -- TODO: do this more cleverly
   |1:
   | mov rax, 0x1
   | jmp >3
   |2:
   | mov rax, 0x0
   |3:

   -- fix stack
   if spilled_space > 0 then
      | add rsp, spilled_space
   end
   | ret

   local mcode, size = Dst:build()
   table.insert(anchor, mcode)

   if dump or debug then
      print("mcode dump:")
      dasm.dump(mcode, size)
   end

   return ffi.cast(ffi.typeof("bool(*)(unsigned char*, uint16_t)"),
                   mcode)
end

function load(ssa, dump)
   local alloc = regalloc.allocate_registers(ssa)
   local fun = compile(ssa, alloc, dump)

   return fun
end

function selftest()
   local ra = require("pf.regalloc")

   -- `ip`
   local example_1 =
      { start = "L1",
	order = { "L1", "L4", "L5" },
	blocks =
	   { L1 = { label = "L1",
		    bindings = {},
		    control = { "if", { ">=", "len", 14 }, "L4", "L5" } },
	     L4 = { label = "L4",
		    bindings = {},
		    control = { "return", { "=", { "[]", 12, 2 }, 8 } } },
	     L5 = { label = "L5",
		    bindings = {},
		    control = { "return", { "false" } } } } }

   -- `arp`
   local example_2 =
      { start = "L1",
	order = { "L1", "L4", "L5" },
	blocks =
	   { L1 = { label = "L1",
		    bindings = {},
		    control = { "if", { ">=", "len", 14 }, "L4", "L5" } },
	     L4 = { label = "L4",
		    bindings = {},
		    control = { "return", { "=", { "[]", 12, 2 }, 1544 } } },
	     L5 = { label = "L5",
		    bindings = {},
		    control = { "return", { "false" } } } } }

   -- `tcp`
   local example_3 =
      { start = "L1",
	order = { "L1", "L4", "L6", "L7", "L8", "L10", "L12", "L13",
		  "L14", "L16", "L17", "L15", "L11", "L9", "L5" },
	blocks =
	   { L1 = { label = "L1",
	            bindings = {},
	            control = { "if", { ">=", "len", 34 }, "L4", "L5" } },
	     L4 = { label = "L4",
	            bindings = { { name = "v1", value = { "[]", 12, 2 } } },
	            control = { "if", { "=", "v1", 8 }, "L6", "L7" } },
	     L6 = { label = "L6",
	            bindings = {},
	            control = { "return", { "=", { "[]", 23, 1 }, 6 } } },
	     L7 = { label = "L7",
	            bindings = {},
	            control = { "if", { ">=", "len", 54 }, "L8", "L9" } },
	     L8 = { label = "L8",
	            bindings = {},
	            control = { "if", { "=", "v1", 56710 }, "L10", "L11" } },
	     L10 = { label = "L10",
	             bindings = { { name = "v2", value = { "[]", 20, 1 } } },
	             control = { "if", { "=", "v2", 6 }, "L12", "L13" } },
	     L12 = { label = "L12",
	             bindings = {},
	             control = { "return", { "true" } } },
	     L13 = { label = "L13",
	             bindings = {},
	             control = { "if", { ">=", "len", 55 }, "L14", "L15" } },
	     L14 = { label = "L14",
	             bindings = {},
	             control = { "if", { "=", "v2", 44 }, "L16", "L17" } },
	     L16 = { label = "L16",
	             bindings = {},
	             control = { "return", { "=", { "[]", 54, 1 }, 6 } } },
	     L17 = { label = "L17",
	             bindings = {},
	             control = { "return", { "false" } } },
	     L15 = { label = "L15",
	             bindings = {},
	             control = { "return", { "false" } } },
	     L11 = { label = "L11",
	             bindings = {},
	             control = { "return", { "false" } } },
	     L9 = { label = "L9",
	            bindings = {},
	            control = { "return", { "false" } } },
	     L5 = { label = "L5",
	            bindings = {},
	            control = { "return", { "false" } } } } }

   local function test(ssa, pkt, regalloc)
      -- Compile and then call native function on the given packet
      local f = compile(ssa, regalloc)
      return f(pkt.packet, pkt.len)
   end

   local savefile = require("pf.savefile")
   arp_pkts = savefile.load_packets("../tests/data/arp.pcap")
   v4_pkts = savefile.load_packets("../tests/data/v4.pcap")
   v6_pkts = savefile.load_packets("../tests/data/v6.pcap")

   local alloc_1 = { num_spilled = 0 }

   -- not an arp packet
   assert(not test(example_1, arp_pkts[1], alloc_1))
   assert(not test(example_1, arp_pkts[2], alloc_1))
   assert(not test(example_1, arp_pkts[2], ra.allocate_registers(example_1)))
   -- yay arp
   assert(test(example_2, arp_pkts[1], alloc_1))
   assert(test(example_2, arp_pkts[2], alloc_1))

   local function test_3(alloc)
      assert(not test(example_3,
                      arp_pkts[1],
                      alloc))
      assert(test(example_3,
                  -- this one is a TCP packet
                  v4_pkts[1],
                  alloc))
      assert(test(example_3,
                  -- this one is also a TCP packet
                  v6_pkts[16],
                  alloc))
   end

   test_3({ v1 = { spill = 1 },
            v2 = { spill = 2 },
            num_spilled = 2 })
   test_3({ v1 = 1, -- %ecx
            v2 = 2, -- %edx
            num_spilled = 0 })
   test_3({ v1 = 8, -- %r8
            v2 = 9, -- %r9
            num_spilled = 0 })
   test_3(ra.allocate_registers(example_3))
end
