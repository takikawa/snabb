module(..., package.seeall)

local ffi = require("ffi")
local bit = require("bit")
local C = ffi.C

local dasm = require("dasm")

|.arch x64
|.actionlist actions

-- Table keeping machine code alive to the GC.
local anchor = {}

local debug = true

local blk_label    = 2
local blk_bindings = 3
local blk_control  = 4

-- Note that we always negate the condition because the ordering
-- of the SSA IR puts the true branch first
local jmp_types =
   { ["=="] = "je",
     [">="] = "jl",
     ["<="] = "jg",
     [">"]  = "jle",
     ["<"]  = "jge", }

-- translate a variable occurrence into the appropriate
-- register, perhaps consulting the register allocation
function translate_variable(var)
  if var == "P" then
    return "edi"
  elseif var == "len" then
    return "esi"
  end
end

-- extract a number from an SSA IR label
function label_num(label)
  return tonumber(string.match(label, "L(%d+)"))
end

-- find the largest label number in the IR
function find_max_label(blocks)
  local max = 1

  for i = 2, #blocks do
    local block = blocks[i]
    local cur = label_num(block[blk_label][2])

    if cur > max then
      max = cur
    end
  end

  return max
end

-- compile an expression that appears in the argument position of a return
function compile_expr(Dst, expr)
  local op = expr[1]

  if op == "=" then
    local lhs = expr[2]
    local rhs = expr[3]

    -- TODO: is it actually the case that rhs is always an immediate?
    compile_expr(Dst, lhs)

    | cmp rax, rhs
    | je =>0
    | jmp =>1
  elseif op == "[]" then
    local offset = expr[2]
    local bytes  = expr[3]

    -- the "P" variable is in %edi since it's the first argument
    if bytes == 1 then
      | movzx eax, byte [edi + offset]
    elseif bytes == 2 then
      | movzx eax, word [edi + offset]
    else
      | mov eax, dword [edi + offset]
    end
  end
end

local function compile_cmp(Dst, var, const, alloc)
   if var == "P" then
      | cmp edi, const
      return
   elseif var == "len" then
      | cmp esi, const
      return
   end

   local reg = alloc[var]

   -- TODO: this hard-coded conditional is unfortunate
   if type(reg) == "table" then
     -- spill case
     local offset = (reg.spill - 1) * 32
     | cmp dword [rsp + offset], const
   elseif reg == "rcx" then
     | cmp rcx, const
   elseif reg == "rdx" then
     | cmp rdx, const
   elseif reg == "r8" then
     | cmp r8, const
   elseif reg == "r9" then
     | cmp r9, const
   elseif reg == "r10" then
     | cmp r10, const
   elseif reg == "r11" then
     | cmp r11, const
   end
end

-- generate a move from rax to the appropriate register
-- TODO: for now we assume that only the caller-save
--       registers rcx, rdx, r8-r11 are used
local function compile_var_move(Dst, var, alloc)
  local reg = alloc[var]

  -- TODO: this hard-coded conditional is unfortunate
  if type(reg) == "table" then
    -- spill case
    local offset = (reg.spill - 1) * 32
    | mov [rsp + offset], rax
  elseif reg == "rcx" then
    | mov rcx, rax
  elseif reg == "rdx" then
    | mov rdx, rax
  elseif reg == "r8" then
    | mov r8, rax
  elseif reg == "r9" then
    | mov r9, rax
  elseif reg == "r10" then
    | mov r10, rax
  elseif reg == "r11" then
    | mov r11, rax
  end
end

local function compile(ssa, alloc)
   local Dst = dasm.new(actions)
   local blocks = ssa[3]

   -- track the mapping of SSA block labels to asm labels
   local label_map = {}

   -- number of =>(...) style labels
   local maxpc = find_max_label(blocks)
   Dst:growpc(maxpc + 3)

   -- allocate space for all spilled vars
   local spilled_space = alloc.num_spilled * 32
   if spilled_space > 0 then
     | sub rsp, spilled_space
   end

   for i = 2, #blocks do
     local block = blocks[i]

     cur_label = label_num(block[blk_label][2]) + 1
     |=>(cur_label):

     local control = block[blk_control][2]
     local op = control[1]

     local bindings = block[blk_bindings]

     for i=2, #bindings do
       local binding = bindings[i]
       local var = binding[1]
       local expr = binding[2]

       compile_expr(Dst, expr)
       compile_var_move(Dst, var, alloc)
     end

     if op == "if" then
       local cmp_op = control[2][1]
       local jmp_instr = jmp_types[cmp_op]
       local const = control[2][3]

       -- TODO: abstract some of this label handling
       local next_label = label_num(control[4]) + 1

       compile_cmp(Dst, control[2][2], const, alloc)

       -- TODO: this feels very hackish
       if cmp_op == "=" then
         | jne =>(next_label)
       elseif cmp_op == ">=" then
         | jl =>(next_label)
       elseif cmp_op == "<=" then
         | jg =>(next_label)
       elseif cmp_op == ">" then
         | jle =>(next_label)
       elseif cmp_op == "<" then
         | jge =>(next_label)
       end
     elseif op == "return" then
       local expr = control[2]

       if #expr == 1 and expr[1] == "true" then
         | jmp =>0
       elseif #expr == 1 and expr[1] == "false" then
         | jmp =>1
       else
         compile_expr(Dst, expr)
       end
     end
   end

   -- return true, false
   -- TODO: do this more cleverly
   |=>0:
   | mov rax, 0x1
   | jmp =>(maxpc+2)
   |=>1:
   | mov rax, 0x0
   |=>(maxpc + 2):

   -- fix stack
   if spilled_space > 0 then
     | add rsp, spilled_space
   end
   | ret

   local mcode, size = Dst:build()
   table.insert(anchor, mcode)

   if debug then
      print("mcode dump:")
      dasm.dump(mcode, size)
   end

   return ffi.cast(ffi.typeof("bool(*)(unsigned char*, uint16_t)"),
                   mcode)
end

function selftest()
   local max_label_example_1 =
      { "blocks",
        { "block",
          { "label", "L1" }, },
        { "block",
          { "label", "L4" }, },
        { "block",
          { "label", "L5" }, } }

   assert(find_max_label(max_label_example_1) == 5)

   -- `ip`
   local example_1 =
      { "ssa",
         { "start", "L1" },
         { "blocks",
            { "block",
               { "label", "L1" },
               { "bindings" },
               { "control",
                  { "if", { ">=", "len", 14 }, "L4", "L5" } } },
            { "block",
               { "label", "L4" },
               { "bindings" },
               { "control",
                  { "return",
                     { "=", { "[]", 12, 2 }, 8 } } } },
            { "block",
               { "label", "L5" },
               { "bindings" },
               { "control", { "return", { "false" } } } } } }

   -- `arp`
   local example_2 =
      { "ssa",
         { "start", "L1" },
         { "blocks",
            { "block",
               { "label", "L1" },
               { "bindings" },
               { "control",
                  { "if", { ">=", "len", 14 }, "L4", "L5" } } },
            { "block",
               { "label", "L4" },
               { "bindings" },
               { "control",
                  { "return", { "=", { "[]", 12, 2 }, 1544 } } } },
            { "block",
               { "label", "L5" },
               { "bindings" },
               { "control", { "return", { "false" } } } } } }

   local example_3 =
      { "ssa",
         { "start", "L1" },
         { "blocks",
            { "block",
               { "label", "L1" },
               { "bindings" },
               { "control",
                  { "if", { ">=", "len", 34 }, "L4", "L5" } } },
            { "block",
               { "label", "L4" },
               { "bindings",
                  { "v1", { "[]", 12, 2 } } },
               { "control",
                  { "if", { "=", "v1", 8 }, "L6", "L7" } } },
            { "block",
               { "label", "L6" },
               { "bindings" },
               { "control",
                  { "return", { "=", { "[]", 23, 1 }, 6 } } } },
            { "block",
               { "label", "L7" },
               { "bindings" },
               { "control",
                  { "if", { ">=", "len", 54 }, "L8", "L9" } } },
            { "block",
               { "label", "L8" },
               { "bindings" },
               { "control",
                  { "if", { "=", "v1", 56710 }, "L10", "L11" } } },
            { "block",
               { "label", "L10" },
               { "bindings",
                  { "v2", { "[]", 20, 1 } } },
               { "control",
                  { "if", { "=", "v2", 6 }, "L12", "L13" } } },
            { "block",
               { "label", "L12" },
               { "bindings" },
               { "control", { "return", { "true" } } } },
            { "block",
               { "label", "L13" },
               { "bindings" },
               { "control",
                 { "if", { ">=", "len", 55 }, "L14", "L15" } } },
            { "block",
               { "label", "L14" },
               { "bindings" },
               { "control",
                 { "if", { "=", "v2", 44 }, "L16", "L17" } } },
            { "block",
               { "label", "L16" },
               { "bindings" },
               { "control",
                  { "return", { "=", { "[]", 54, 1 }, 6 } } } },
            { "block",
               { "label", "L17" },
               { "bindings" },
               { "control", { "return", { "false" } } } },
            { "block",
               { "label", "L15" },
               { "bindings" },
               { "control", { "return", { "false" } } } },
            { "block",
               { "label", "L11" },
               { "bindings" },
               { "control", { "return", { "false" } } } },
            { "block",
               { "label", "L9" },
               { "bindings" },
               { "control", { "return", { "false" } } } },
            { "block",
               { "label", "L5" },
               { "bindings" },
               { "control", { "return", { "false" } } } } } }

   local function test(ssa, pkt, regalloc)
      -- Compile and then call native function on the given packet
      local f = compile(ssa, regalloc)
      return f(pkt.packet, pkt.len)
   end

   local savefile = require("pf.savefile")
   arp_pkts = savefile.load_packets("../tests/data/arp.pcap")
   v4_pkts = savefile.load_packets("../tests/data/v4.pcap")
   v6_pkts = savefile.load_packets("../tests/data/v6.pcap")

   local alloc_1 = { num_spilled = 0 }

   -- not an arp packet
   assert(not test(example_1, arp_pkts[1], alloc_1))
   assert(not test(example_1, arp_pkts[2], alloc_1))
   -- yay arp
   assert(test(example_2, arp_pkts[1], alloc_1))
   assert(test(example_2, arp_pkts[2], alloc_1))

   assert(not test(example_3,
                   arp_pkts[1],
                   { v1 = { spill = 1 },
                     v2 = { spill = 2 },
                     num_spilled = 2 }))
   assert(test(example_3,
               -- this one is a TCP packet
               v4_pkts[1],
               { v1 = { spill = 1 },
                 v2 = { spill = 2 },
                 num_spilled = 2 }))
   assert(test(example_3,
               -- this one is also a TCP packet
               v6_pkts[16],
               { v1 = { spill = 1 },
                 v2 = { spill = 2 },
                 num_spilled = 2 }))
end
